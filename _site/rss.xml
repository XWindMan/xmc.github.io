<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WindMan Blog</title>
    <description>风一样de男子</description>
    <link>//</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 31 Aug 2020 00:34:16 +0800</pubDate>
    <lastBuildDate>Mon, 31 Aug 2020 00:34:16 +0800</lastBuildDate>
    <generator>Jekyll v4.1.0</generator>
    
      <item>
        <title>kotlin 内联函数</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;let和with合并为run，孪生出apply，also又孪生与let&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;let，it代理对象，且返回最后一行代码或者指定return&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.let{
    it// 此时it就代理了a
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;with，返回最后一行代码或者指定return&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with(a){
    // 此时此作用于有个this，可省略，直接调用a的对象
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;run let和with的补充，省略了let内的it，解决了with调用之前的判空&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a?.run{
    // 此时可以直接调用a的参数
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;apply，与run是孪生兄弟，唯一不同的是返回对象本身；还可以用来判空链式写法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a?.apply{
    // 此时可以省略啊直接调用a对象的成员
    // 返回a
}

// 如果a中有b，b有b1

a?.apply{
    b?.apply{

    }?.b1.apply{

    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;also let的孪生兄弟，返回对象本省&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.also{
    it.// it 代理a
    // 最终返回a
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 31 Aug 2020 00:00:00 +0800</pubDate>
        <link>/2020/08/31/kotlin%E5%86%85%E8%81%94.html</link>
        <guid isPermaLink="true">/2020/08/31/kotlin%E5%86%85%E8%81%94.html</guid>
        
        <category>kotlin</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Android第一侠客activity</title>
        <description>&lt;ul&gt;
  &lt;li&gt;配置name是唯一必要的，其他都是自定义：标签、主题等&lt;/li&gt;
  &lt;li&gt;可配置强大的intent过滤器&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 30 Aug 2020 00:00:00 +0800</pubDate>
        <link>/2020/08/30/activity.html</link>
        <guid isPermaLink="true">/2020/08/30/activity.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>双鱼男与12星座搭配</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;最佳配对：巨蟹座女、天蝎座女、摩羯座女&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;白羊女&quot;&gt;白羊女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;他的罗曼蒂克令人响往，但他的情绪起伏让你吃不消。你的直言无讳可能会把他吓跑。如果想要他你得做只绵羊才行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;金牛女&quot;&gt;金牛女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;他总是那么温和，那么善解人意，唯一让你担心的是，他的想法会不会离现实太远了呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;双子女&quot;&gt;双子女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;你的性格多变，他的情绪多变，如果你们都能接受方“变”的本质，或许还有可为。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;巨蟹女&quot;&gt;巨蟹女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;鱼座的男人多情本性会让你十分窝心。而巨蟹座女子的母性特质，也正是双鱼男人深切需要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;狮子女&quot;&gt;狮子女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;他绝对可以满足你渴望恋爱的欲望。但是当你们一起面对现实生活时，冲突可能就要发生了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;处女&quot;&gt;处女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;虽然彼此都很乐于分担对方的喜乐忧伤，但是，基本上双鱼座的浪漫和处女座的实际却有着很大的冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;天秤&quot;&gt;天秤&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;情绪起伏大的他，性格上和你差距很大。虽然有些时侯你们在一起会觉得很过瘾，但多数时侯仍下步调不一的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;天蝎女&quot;&gt;天蝎女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;你们的心灵很容易相通，彼此能完全体会到对方的爱。在生活上，你通常得要扮演照顾他的角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;射手女&quot;&gt;射手女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;他是很容易引发你“南丁格尔”情结的男人，虽然个性不同，但你总会有想要陪伴他、照顾他的念头。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;摩羯女&quot;&gt;摩羯女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;你们或许可以倾心交谈，成为相互了解的知己。但实际生活在一起，就会有许多相抵触的地方。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;水瓶女&quot;&gt;水瓶女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;不要以自己知性的态度去看双鱼座男子的世界。你们或许不太容易起共呜，但发生冲突的机会也不大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;双鱼女&quot;&gt;双鱼女&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;两只鱼的搭配，自然“永浴爱河”的机会很大。就怕情绪暗潮汹涌时，两人会游向相反的方向。方觉得非常愉快的性伴侣。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Aug 2020 00:00:00 +0800</pubDate>
        <link>/2020/08/30/12%E6%98%9F%E5%BA%A7%E5%A5%B3%E4%B8%8E%E5%8F%8C%E9%B1%BC%E7%94%B7%E7%9A%84%E6%90%AD%E9%85%8D.html</link>
        <guid isPermaLink="true">/2020/08/30/12%E6%98%9F%E5%BA%A7%E5%A5%B3%E4%B8%8E%E5%8F%8C%E9%B1%BC%E7%94%B7%E7%9A%84%E6%90%AD%E9%85%8D.html</guid>
        
        <category>星座</category>
        
        
        <category>星座</category>
        
      </item>
    
      <item>
        <title>Android 碎片记忆</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一片，两片，三四片；五片，六片，七八片。落入芦苇全不见！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;h5唤起app&quot;&gt;h5唤起app&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ [scheme:][//authority][path][?query][#fragment],如：https://www.baidu.com
+ scheme的触发方式会被浏览器拦截，它们都各自维护着一个白名单，但是微博之类的都是可以申请的，只是条件各不相同，比如微博的就是在你的 APP 中添加打开微博的入口，三个月内唤起超过 100w 次，就可以加入白名单了。
+ 在安卓中我们一般都是直接打开腾讯应用宝，ios 中 直接打开 App Store。点击腾讯应用宝中的“打开”按钮，可以直接唤起我们的 APP，但是无法打开 APP 中的某个功能（就是无法打开指定页面）。腾讯应用宝对外开放了一个叫做 APP Link 的申请，只要你申请了 APP Link，就可以通过在打开应用宝的时候在应用宝地址后面添加上 &amp;amp;android_schema={your_scheme} ，来打开指定的页面了。
+ location.href跳转：window.location.href = 'sinaweibo://qrcode';
+ a标签唤起： &amp;lt;a href=&quot;mqqapi://card/show_pslcard?src_type=internal&amp;amp;version=1&amp;amp;uin=123456&quot;&amp;gt;QQ临时交流&amp;lt;/a&amp;gt;
+ iframe方案： &amp;lt;iframe src=&quot;sinaweibo://qrcode&quot;&amp;gt;

参考：https://www.jianshu.com/p/500f4be528e3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;android-9-允许http&quot;&gt;Android 9+ 允许http&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;res目录下创建xml目录,创建network_security_config.xml文件
```
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;network-security-config&gt;
&lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;
&lt;/network-security-config&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ AndroidManifest.xml添加:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;android:networkSecurityConfig=”@xml/network_security_config”&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
## Android8.0 允许安装未知来源权限
+ 8.0之前，从除官方应用商店之外的来源安装App时，需要打开系统设置当中的”允许未知来源”，在最新的Android O当中谷歌已经删除了该永久授权的选项，从系统设置当中已经找不到该开关。谷歌将永久授权修改为每次的单独授权，当用户每次安装第三方来源（包括华为应用市场等）的android软件时需要对软件权限进行手动确认
+ 添加权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ 判断运行时权限是否打开
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;if(Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O){
 //先判断是否有安装未知来源应用的权限
    if(!getPackageManager().canRequestPackageInstalls()){
    //跳转到应用详情，打开开关
    }
 }&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ 跳转到应用详情，打开开关
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Uri packageURI = Uri.parse(“package:”+mContext.getPackageName());
Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES,packageURI);
startActivityForResult(intent, INSTALL_PERMISS_CODE);&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ onActivityResult回调
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;if (resultCode == RESULT_OK &amp;amp;&amp;amp; requestCode == INSTALL_PERMISS_CODE) {
   // 安装APP
 }&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
## AlertDialog 回调 
+ 创建 AlertDialog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void showAlert(Context context, String title, String message, OnClickListener listener){
    Builder builder = new Builder(context);
    builder.setTitle(title);
    builder.setMessage(message);
    builder.setPositiveButton(&quot;确定&quot;, listener);
    builder.setCancelable(false);
    builder.setIcon(R.mipmap.ic_launcher);
    AlertDialog dialog = builder.create();
    dialog.show();
} ``` + 接管点击事件 ``` showAlert(this, &quot;title&quot;, &quot;message&quot;, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    
                }
            }); ``` ## TextView 小特性 + 可复制，如果是在listview里，替换为RecyclerView 即可 ``` android:textIsSelectable=&quot;true&quot; ``` + 可滑动 ```  tv.movementMethod = ScrollingMovementMethod.getInstance() ``` + 支持富文本:SpannableString或者html ``` //设置Hello World前三个字符为红色,背景为蓝色 SpannableString textSpanned = new SpannableString(&quot;Hello World&quot;); // ForegroundColorSpan(Color.RED) 设置前景 // BackgroundColorSpan(Color.RED) 设置背景 // new StyleSpan(Typeface.ITALIC) 斜体 // new UnderlineSpan() 下划线 // ClickableSpan 点击事件 textSpanned.setSpan(xxxSpan,0, 3, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); tv.setMovementMethod(LinkMovementMethod.getInstance()); tv.setText(textSpanned4); ``` + 跑马灯：借助系统或者自定义或者直接用别人的轮子 ```
&amp;lt;TextView
    android:layout_marginTop=&quot;30dp&quot;
    android:layout_width=&quot;100dp&quot;
    android:layout_height=&quot;30dp&quot;
    android:text=&quot;Hello World! wertyuiodfghjklxcvbnm,.dfghjklghjkl&quot;
    android:singleLine=&quot;true&quot;
    android:scrollHorizontally=&quot;true&quot;
    android:ellipsize=&quot;marquee&quot;
    android:focusable=&quot;true&quot;
    android:focusableInTouchMode=&quot;true&quot;
    android:marqueeRepeatLimit=&quot;marquee_forever&quot;
    /&amp;gt; ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;android-多国语言&quot;&gt;android 多国语言&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;报错is-not-accessible-from-javalangclass-androidappactivitythread&quot;&gt;【报错】is not accessible from java.lang.Class android.app.ActivityThread&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;修饰改为public&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 29 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/29/%E7%A2%8E%E7%89%87%E8%AE%B0%E5%BF%86.html</link>
        <guid isPermaLink="true">/2020/07/29/%E7%A2%8E%E7%89%87%E8%AE%B0%E5%BF%86.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>排序</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;十大排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;从前往后，每一次，交换一个前者大于后者的位置&lt;/li&gt;
  &lt;li&gt;最大排序次数情况：整个数据倒序&lt;/li&gt;
  &lt;li&gt;最大排序次数：n*（n-1）/2
```
/**&lt;/li&gt;
  &lt;li&gt;冒泡排序
 */
function bubbleSort(arr) {
 let time=0
 var len = arr.length;
 for (var i = 0; i &amp;lt; len - 1; i++) {
     for (var j = 0; j &amp;lt; len - 1 - i; j++) {
         if (arr[j] &amp;gt; arr[j + 1]) {// 相邻元素两两对比
             var temp = arr[j + 1];// 元素交换
             arr[j + 1] = arr[j];
             arr[j] = temp;
             time++;
             // console.log(j, arr[j])
             // console.log(j + 1, arr[j])
             console.log(time,’bubbleSort: ‘, arr)
             console.log(‘——————-‘)
         }
     }
 }
 console.log(‘bubbleSort: ‘, arr)
 return arr;
}
```
    &lt;h2 id=&quot;选择排序&quot;&gt;选择排序&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;找到最小数，记住下标，从0以此 往后排，且和当前同下标数据交换位置&lt;/li&gt;
  &lt;li&gt;排序次数一定等于n-1&lt;/li&gt;
  &lt;li&gt;排序次数变小，但是寻找最小数次数很多
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function selectionSort(arr) {
  var len = arr.length;
  var minIndex, temp;
  for (var i = 0; i &amp;lt; len - 1; i++) {
      minIndex = i;
      for (var j = i + 1; j &amp;lt; len; j++) {
          if (arr[j] &amp;lt; arr[minIndex]) {// 寻找最小的数
              minIndex = j;// 将最小数的索引保存
          }
      }
      temp = arr[i];
      arr[i] = arr[minIndex];
      arr[minIndex] = temp;
      console.log(minIndex, 'selectionSort: ', arr)
      console.log('-------------------')
  }
  return arr;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;插入排序&quot;&gt;插入排序&lt;/h2&gt;
    &lt;p&gt;```
/**&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;插入排序
 */
function insertionSort(arr) {
 var len = arr.length;
 var preIndex, current;
 for (var i = 1; i &amp;lt; len; i++) {
     preIndex = i - 1;
     current = arr[i];
     while (preIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[preIndex] &amp;gt; current) {
         arr[preIndex + 1] = arr[preIndex];
         preIndex–;
     }
     arr[preIndex + 1] = current;
 }
 return arr;
}
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 希尔排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;function shellSort(arr) {
 var len = arr.length;
 for(var gap = Math.floor(len / 2); gap &amp;gt; 0; gap = Math.floor(gap / 2)) {
     // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
     for(var i = gap; i &amp;lt; len; i++) {
         var j = i;
         varcurrent = arr[i];
         while(j - gap &amp;gt;= 0 &amp;amp;&amp;amp; current &amp;lt; arr[j - gap]) {
              arr[j] = arr[j - gap];
              j = j - gap;
         }
         arr[j] = current;
     }
 }
 return arr;
}&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 归并排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;function mergeSort(arr) {
 var len = arr.length;
 if(len &amp;lt; 2) {
     retur narr;
 }
 var middle = Math.floor(len / 2),
     left = arr.slice(0, middle),
     right = arr.slice(middle);
 return merge(mergeSort(left), mergeSort(right));
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;function merge(left, right) {
    var result = [];&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while(left.length&amp;gt;0 &amp;amp;&amp;amp; right.length&amp;gt;0) {
    if(left[0] &amp;lt;= right[0]) {
        result.push(left.shift());
    } else{
        result.push(right.shift());
    }
}
 
while(left.length)
    result.push(left.shift());
 
while(right.length)
    result.push(right.shift());
 
return result; } ``` ## 快速排序 ``` function quickSort(arr, left, right) {
var len = arr.length,
    partitionIndex,
    left = typeofleft != 'number'? 0 : left,
    right = typeofright != 'number'? len - 1 : right;
 
if(left &amp;lt; right) {
    partitionIndex = partition(arr, left, right);
    quickSort(arr, left, partitionIndex-1);
    quickSort(arr, partitionIndex+1, right);
}
return arr; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for(var i = index; i &amp;lt;= right; i++) {
        if(arr[i] &amp;lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }     &lt;br /&gt;
    }
    swap(arr, pivot, index - 1);
    return index-1;
}&lt;/p&gt;

&lt;p&gt;function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 堆排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量&lt;/p&gt;

&lt;p&gt;function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for(var i = Math.floor(len/2); i &amp;gt;= 0; i–) {
        heapify(arr, i);
    }
}&lt;/p&gt;

&lt;p&gt;function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(left &amp;lt; len &amp;amp;&amp;amp; arr[left] &amp;gt; arr[largest]) {
    largest = left;
}
 
if(right &amp;lt; len &amp;amp;&amp;amp; arr[right] &amp;gt; arr[largest]) {
    largest = right;
}
 
if(largest != i) {
    swap(arr, i, largest);
    heapify(arr, largest);
} }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}&lt;/p&gt;

&lt;p&gt;function heapSort(arr) {
    buildMaxHeap(arr);&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(var i = arr.length - 1; i &amp;gt; 0; i--) {
    swap(arr, 0, i);
    len--;
    heapify(arr, 0);
}
return arr; } ``` ## 计数排序 ``` function countingSort(arr, maxValue) {
var bucket = newArray(maxValue + 1),
    sortedIndex = 0;
    arrLen = arr.length,
    bucketLen = maxValue + 1;
 
for(var i = 0; i &amp;lt; arrLen; i++) {
    if(!bucket[arr[i]]) {
        bucket[arr[i]] = 0;
    }
    bucket[arr[i]]++;
}
 
for(var j = 0; j &amp;lt; bucketLen; j++) {
    while(bucket[j] &amp;gt; 0) {
        arr[sortedIndex++] = j;
        bucket[j]--;
    }
}
 
return arr; } ``` ## 桶排序 ``` function bucketSort(arr, bucketSize) {
if(arr.length === 0) {
  returnarr;
}
 
var i;
var minValue = arr[0];
var maxValue = arr[0];
for(i = 1; i &amp;lt; arr.length; i++) {
  if(arr[i] &amp;lt; minValue) {
      minValue = arr[i];                // 输入数据的最小值
  } else if(arr[i] &amp;gt; maxValue) {
      maxValue = arr[i];                // 输入数据的最大值
  }
}
 
// 桶的初始化
var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  
var buckets = newArray(bucketCount);
for(i = 0; i &amp;lt; buckets.length; i++) {
    buckets[i] = [];
}
 
// 利用映射函数将数据分配到各个桶中
for(i = 0; i &amp;lt; arr.length; i++) {
    buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
}
 
arr.length = 0;
for(i = 0; i &amp;lt; buckets.length; i++) {
    insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
    for(var j = 0; j &amp;lt; buckets[i].length; j++) {
        arr.push(buckets[i][j]);                     
    }
}
 
return arr; } ``` ## 基数排序 ``` var counter = []; function radixSort(arr, maxDigit) {
var mod = 10;
var dev = 1;
for(var i = 0; i &amp;lt; maxDigit; i++, dev *= 10, mod *= 10) {
    for(var j = 0; j &amp;lt; arr.length; j++) {
        varbucket = parseInt((arr[j] % mod) / dev);
        if(counter[bucket]==null) {
            counter[bucket] = [];
        }
        counter[bucket].push(arr[j]);
    }
    var pos = 0;
    for(var j = 0; j &amp;lt; counter.length; j++) {
        var value = null;
        if(counter[j]!=null) {
            while((value = counter[j].shift()) != null) {
                  arr[pos++] = value;
            }
      }
    }
}
return arr; } ``` 参考：https://www.cnblogs.com/onepixel/p/7674659.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 28 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/28/%E6%8E%92%E5%BA%8F.html</link>
        <guid isPermaLink="true">/2020/07/28/%E6%8E%92%E5%BA%8F.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Android面基2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Android 相关部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;自定义-view&quot;&gt;自定义 View&lt;/h2&gt;
&lt;h2 id=&quot;事件拦截分发&quot;&gt;事件拦截分发&lt;/h2&gt;
&lt;h2 id=&quot;性能优化工具&quot;&gt;性能优化工具&lt;/h2&gt;
&lt;h2 id=&quot;https请求慢的解决办法dns携带数据直接访问-ip&quot;&gt;Http[s]请求慢的解决办法（DNS、携带数据、直接访问 IP）&lt;/h2&gt;
&lt;h2 id=&quot;缓存自己如何实现lrucache-原理&quot;&gt;缓存自己如何实现（LRUCache 原理）&lt;/h2&gt;
&lt;h2 id=&quot;图形图像相关opengl-es-管线流程egl-的认识shader-相关&quot;&gt;图形图像相关：OpenGL ES 管线流程、EGL 的认识、Shader 相关&lt;/h2&gt;
&lt;h2 id=&quot;surfaceviewtextureviewglsurfaceview-区别及使用场景&quot;&gt;SurfaceView、TextureView、GLSurfaceView 区别及使用场景&lt;/h2&gt;
&lt;h2 id=&quot;动画差值器估值器android中的view动画和属性动画-android-动画-介绍与使用&quot;&gt;动画、差值器、估值器（Android中的View动画和属性动画 、Android 动画 介绍与使用）&lt;/h2&gt;
&lt;h2 id=&quot;mvcmvpmvvm&quot;&gt;MVC、MVP、MVVM&lt;/h2&gt;
&lt;h2 id=&quot;handlerthreadlocalasynctaskintentservice-原理及应用&quot;&gt;Handler、ThreadLocal、AsyncTask、IntentService 原理及应用&lt;/h2&gt;
&lt;h2 id=&quot;gradlegroovy-语法gradle-插件开发基础&quot;&gt;Gradle（Groovy 语法、Gradle 插件开发基础）&lt;/h2&gt;
&lt;h2 id=&quot;热修复插件化&quot;&gt;热修复、插件化&lt;/h2&gt;
&lt;h2 id=&quot;组件化架构思路&quot;&gt;组件化架构思路&lt;/h2&gt;
&lt;h2 id=&quot;系统打包流程&quot;&gt;系统打包流程&lt;/h2&gt;
&lt;h2 id=&quot;android-有哪些存储数据的方式&quot;&gt;Android 有哪些存储数据的方式。&lt;/h2&gt;
&lt;h2 id=&quot;sharedprefrence-源码和问题点&quot;&gt;SharedPrefrence 源码和问题点；&lt;/h2&gt;
&lt;h2 id=&quot;sqlite-相关&quot;&gt;sqlite 相关&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;创建或者打开数据库
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class DBHelper extends SQLiteOpenHelper {
  private static final String DATABASE_NAME = &quot;db.db&quot;;
  private static final int DATABASE_VERSION = 1;

  /** Create a helper object for the Events database */
  public ProvinceDataHelper(Context ctx) {
      super(ctx, DATABASE_NAME, null, DATABASE_VERSION);
  }

  @Override
  public void onCreate(SQLiteDatabase db) {}

  @Override
  public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;增删改查
```&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

+ 如何导入外部数据库
1.将格式为.db的数据库文件放到android项目assets目录中；
2.在程序必要的时候，将其“拷贝”（文件读取）到Android 程序默认的数据库存储目录中，一般路径为“/data/data/项目包名/databases/“；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;InputStream is = context.getAssets().open(DB_NAME);
                // 输出流,在指定路径下生成db文件
                OutputStream os = new FileOutputStream(DB_PATH + DB_NAME);&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            // 文件写入
            byte[] buffer = new byte[1024];
            int length;
            while ((length = is.read(buffer)) &amp;gt; 0) {
                os.write(buffer, 0, length);
            } ``` 3.自定义SQLiteOpenHelper类，创建一个名字跟步骤1中.db名称一样的数据库； 4.按照平常逻辑，增删改查数据库。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h2 id=&quot;如何判断一个-app-在前台还是后台&quot;&gt;如何判断一个 APP 在前台还是后台？&lt;/h2&gt;
&lt;h2 id=&quot;ams-pms&quot;&gt;AMS 、PMS&lt;/h2&gt;
&lt;h2 id=&quot;activity-启动流程app-启动流程&quot;&gt;Activity 启动流程，App 启动流程&lt;/h2&gt;
&lt;h2 id=&quot;binder-机制ipcaidl-的使用&quot;&gt;Binder 机制（IPC、AIDL 的使用）&lt;/h2&gt;
&lt;h2 id=&quot;为什么使用-parcelable好处是什么&quot;&gt;为什么使用 Parcelable，好处是什么？&lt;/h2&gt;
&lt;h2 id=&quot;android-图像显示相关流程vsync-信号等&quot;&gt;Android 图像显示相关流程，Vsync 信号等&lt;/h2&gt;
&lt;h2 id=&quot;invalidate和postinvalidate的区别及使用&quot;&gt;invalidate和postInvalidate的区别及使用&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Android中实现View的更新有两组方法，1. invalidate,ui线程更新; 2. postInvalidate，非UI线程更新&lt;/li&gt;
  &lt;li&gt;invalidate是在handler中使用，postInvalidate可以直接在子线程中调用更新View。
    &lt;h2 id=&quot;activity-window-view三者的差别&quot;&gt;Activity-Window-View三者的差别&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Activity是Android四大组件之一，负责界面展示、用户交互和逻辑处理,有一个内部对象window。&lt;/li&gt;
  &lt;li&gt;Window就是负责界面展示以及交互的只能部门，就相当于Activity的下属，Activity的生命周期方法负责业务的处理。&lt;/li&gt;
  &lt;li&gt;View就是放在Window容器的元素，Window是View的载体，View是Window的具体展示。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 在Activity中调用attach，创建了一个Window
2. 创建的window是其子类PhoneWindow，在attach中创建PhoneWindow
3. 在Activity中调用setContentView(R.layout.xxx)
4. 其中实际上是调用的getWindow().setContentView()
5. 调用PhoneWindow中的setContentView方法
6. 创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）
7. 将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】
8. 调用到ViewGroup
9. 调用ViewGroup的removeAllView()，先将所有的view移除掉
10. 添加新的view：addView()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;context&quot;&gt;Context&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Context数量=Activity数量+Service数量+1&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 27 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/27/Android%E9%9D%A2%E5%9F%BA-2.html</link>
        <guid isPermaLink="true">/2020/07/27/Android%E9%9D%A2%E5%9F%BA-2.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Android 面试 Java部分</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;java 相关&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;容器（HashMap、HashSet、LinkedList、ArrayList、数组等）
内存模型
垃圾回收算法（JVM）
垃圾回收机制和调用 System.gc()的区别？
类加载过程（需要多看看，重在理解，对于热修复和插件化比较重要）
反射
多线程和线程池
设计模式（六大基本原则、项目中常用的设计模式、手写单例等）
Java 四大引用
Java 的泛型
final、finally、finalize 的区别
接口、抽象类的区别&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/27/Android-%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80.html</link>
        <guid isPermaLink="true">/2020/07/27/Android-%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>http 及其抓包</title>
        <description>
</description>
        <pubDate>Sat, 18 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/18/Android-http.html</link>
        <guid isPermaLink="true">/2020/07/18/Android-http.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>svg 在Android中的使用</title>
        <description>
</description>
        <pubDate>Fri, 17 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/17/svg.html</link>
        <guid isPermaLink="true">/2020/07/17/svg.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>node jwt 苹果登录验证</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;苹果登录有两种方式验证：jwt形式；code授权码形式.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jwt&quot;&gt;jwt&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;格式：heard.paylod.signture&lt;/li&gt;
  &lt;li&gt;signtura生成方式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;解析之后
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ header: {
   kid: '86D32Kf',
   alg: 'RS256' 
 },
payload: 
 { iss: 'https://appleid.apple.com',
   aud: 'com.company.product',
   exp: 1594712245,
   iat: 1594711645,
   sub: '001610.d0b9dfa70cc24cd79f5bba662c625102.0718',
   c_hash: 'tlydpf-lV51Gi2pKAGZKCA',
   email: '5u2nbamwvm@privaterelay.appleid.com',
   email_verified: 'true',
   is_private_email: 'true',
   auth_time: 1594711645,
   nonce_supported: true },
signature:'es-mMU2FRsILnqmo_G5VbNKMz9gHtL9GjtyuiiiiiiiiP5J9ZhttU1_EJBEDBkBnR1jcrq_xM7kCpq357aN_EAC6G7bgGq4_RrAlG8XwEj4RSo1GoYQX1F0sby0SQrf1D_NZzdirjuUX7yNf-ZoeglyBg-7e-CbTjqfYBOswh_jsTWZ-I3vM-Ctcg12E5tUk345678jzaKpzIuL4KvlALM-VrY-Wp_7mFj4a3KKAxls0ojAjD434EL6oPDT8452j8QOWRFtPRttrqLqfpQbJJeXMCJkW5qIKeI9CU7v6Bpo5RLz3P8yGLrUoY3UJXyKT5_5MEs2bbw' }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nodejs实现&quot;&gt;nodejs实现&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var jwt = require('jsonwebtoken');
const jwksClient = require('jwks-rsa');
// 获取苹果公钥json
var jwt_client = jwksClient({
    jwksUri: 'https://appleid.apple.com/auth/keys'
});
exports.verifyAppleSignin = function(req, res) {
    let jwtToken = req.param('jwtToken');
    // 解析出完整的jwt数据
    let jwtStr = jwt.decode(jwtToken, { complete: true })
    jwt_client.getSigningKey(jwtStr.header.kid, function(err, key) {
        // 通过header里的kid和公钥json里的kid匹配，生成公钥
        // 当然也可以自己通过n和e生成公钥
        let signingKey = key.rsaPublicKey;
        // 验证，是否一致
        jwt.verify(jwtToken, signingKey, (err, data) =&amp;gt; {
            if (!err) {
                console.log('verifyAppleSignin,verify ok')
            } else {
                console.log('err', err);
            }
        })
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 01 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/01/node%E8%8B%B9%E6%9E%9C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.html</link>
        <guid isPermaLink="true">/2020/07/01/node%E8%8B%B9%E6%9E%9C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.html</guid>
        
        <category>nodejs</category>
        
        
        <category>nodejs</category>
        
      </item>
    
  </channel>
</rss>
