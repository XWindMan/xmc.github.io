<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WindMan Blog</title>
    <description>风一样de男子</description>
    <link>//</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 30 Jul 2020 00:24:10 +0800</pubDate>
    <lastBuildDate>Thu, 30 Jul 2020 00:24:10 +0800</lastBuildDate>
    <generator>Jekyll v4.1.0</generator>
    
      <item>
        <title>Android 碎片记忆</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;一片，两片，三四片；五片，六片，七八片。落入芦苇全不见！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;h5唤起app&quot;&gt;h5唤起app&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ [scheme:][//authority][path][?query][#fragment],如：https://www.baidu.com
+ scheme的触发方式会被浏览器拦截，它们都各自维护着一个白名单，但是微博之类的都是可以申请的，只是条件各不相同，比如微博的就是在你的 APP 中添加打开微博的入口，三个月内唤起超过 100w 次，就可以加入白名单了。
+ 在安卓中我们一般都是直接打开腾讯应用宝，ios 中 直接打开 App Store。点击腾讯应用宝中的“打开”按钮，可以直接唤起我们的 APP，但是无法打开 APP 中的某个功能（就是无法打开指定页面）。腾讯应用宝对外开放了一个叫做 APP Link 的申请，只要你申请了 APP Link，就可以通过在打开应用宝的时候在应用宝地址后面添加上 &amp;amp;android_schema={your_scheme} ，来打开指定的页面了。
+ location.href跳转：window.location.href = 'sinaweibo://qrcode';
+ a标签唤起： &amp;lt;a href=&quot;mqqapi://card/show_pslcard?src_type=internal&amp;amp;version=1&amp;amp;uin=123456&quot;&amp;gt;QQ临时交流&amp;lt;/a&amp;gt;
+ iframe方案： &amp;lt;iframe src=&quot;sinaweibo://qrcode&quot;&amp;gt;

参考：https://www.jianshu.com/p/500f4be528e3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;##&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/29/%E7%A2%8E%E7%89%87%E8%AE%B0%E5%BF%86.html</link>
        <guid isPermaLink="true">/2020/07/29/%E7%A2%8E%E7%89%87%E8%AE%B0%E5%BF%86.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>排序</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;十大排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;从前往后，每一次，交换一个前者大于后者的位置&lt;/li&gt;
  &lt;li&gt;最大排序次数情况：整个数据倒序&lt;/li&gt;
  &lt;li&gt;最大排序次数：n*（n-1）/2
```
/**&lt;/li&gt;
  &lt;li&gt;冒泡排序
 */
function bubbleSort(arr) {
 let time=0
 var len = arr.length;
 for (var i = 0; i &amp;lt; len - 1; i++) {
     for (var j = 0; j &amp;lt; len - 1 - i; j++) {
         if (arr[j] &amp;gt; arr[j + 1]) {// 相邻元素两两对比
             var temp = arr[j + 1];// 元素交换
             arr[j + 1] = arr[j];
             arr[j] = temp;
             time++;
             // console.log(j, arr[j])
             // console.log(j + 1, arr[j])
             console.log(time,’bubbleSort: ‘, arr)
             console.log(‘——————-‘)
         }
     }
 }
 console.log(‘bubbleSort: ‘, arr)
 return arr;
}
```
    &lt;h2 id=&quot;选择排序&quot;&gt;选择排序&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;找到最小数，记住下标，从0以此 往后排，且和当前同下标数据交换位置&lt;/li&gt;
  &lt;li&gt;排序次数一定等于n-1&lt;/li&gt;
  &lt;li&gt;排序次数变小，但是寻找最小数次数很多
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function selectionSort(arr) {
  var len = arr.length;
  var minIndex, temp;
  for (var i = 0; i &amp;lt; len - 1; i++) {
      minIndex = i;
      for (var j = i + 1; j &amp;lt; len; j++) {
          if (arr[j] &amp;lt; arr[minIndex]) {// 寻找最小的数
              minIndex = j;// 将最小数的索引保存
          }
      }
      temp = arr[i];
      arr[i] = arr[minIndex];
      arr[minIndex] = temp;
      console.log(minIndex, 'selectionSort: ', arr)
      console.log('-------------------')
  }
  return arr;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;插入排序&quot;&gt;插入排序&lt;/h2&gt;
    &lt;p&gt;```
/**&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;插入排序
 */
function insertionSort(arr) {
 var len = arr.length;
 var preIndex, current;
 for (var i = 1; i &amp;lt; len; i++) {
     preIndex = i - 1;
     current = arr[i];
     while (preIndex &amp;gt;= 0 &amp;amp;&amp;amp; arr[preIndex] &amp;gt; current) {
         arr[preIndex + 1] = arr[preIndex];
         preIndex–;
     }
     arr[preIndex + 1] = current;
 }
 return arr;
}
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 希尔排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;function shellSort(arr) {
 var len = arr.length;
 for(var gap = Math.floor(len / 2); gap &amp;gt; 0; gap = Math.floor(gap / 2)) {
     // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
     for(var i = gap; i &amp;lt; len; i++) {
         var j = i;
         varcurrent = arr[i];
         while(j - gap &amp;gt;= 0 &amp;amp;&amp;amp; current &amp;lt; arr[j - gap]) {
              arr[j] = arr[j - gap];
              j = j - gap;
         }
         arr[j] = current;
     }
 }
 return arr;
}&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 归并排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;function mergeSort(arr) {
 var len = arr.length;
 if(len &amp;lt; 2) {
     retur narr;
 }
 var middle = Math.floor(len / 2),
     left = arr.slice(0, middle),
     right = arr.slice(middle);
 return merge(mergeSort(left), mergeSort(right));
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;function merge(left, right) {
    var result = [];&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while(left.length&amp;gt;0 &amp;amp;&amp;amp; right.length&amp;gt;0) {
    if(left[0] &amp;lt;= right[0]) {
        result.push(left.shift());
    } else{
        result.push(right.shift());
    }
}
 
while(left.length)
    result.push(left.shift());
 
while(right.length)
    result.push(right.shift());
 
return result; } ``` ## 快速排序 ``` function quickSort(arr, left, right) {
var len = arr.length,
    partitionIndex,
    left = typeofleft != 'number'? 0 : left,
    right = typeofright != 'number'? len - 1 : right;
 
if(left &amp;lt; right) {
    partitionIndex = partition(arr, left, right);
    quickSort(arr, left, partitionIndex-1);
    quickSort(arr, partitionIndex+1, right);
}
return arr; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for(var i = index; i &amp;lt;= right; i++) {
        if(arr[i] &amp;lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }     &lt;br /&gt;
    }
    swap(arr, pivot, index - 1);
    return index-1;
}&lt;/p&gt;

&lt;p&gt;function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 堆排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量&lt;/p&gt;

&lt;p&gt;function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for(var i = Math.floor(len/2); i &amp;gt;= 0; i–) {
        heapify(arr, i);
    }
}&lt;/p&gt;

&lt;p&gt;function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(left &amp;lt; len &amp;amp;&amp;amp; arr[left] &amp;gt; arr[largest]) {
    largest = left;
}
 
if(right &amp;lt; len &amp;amp;&amp;amp; arr[right] &amp;gt; arr[largest]) {
    largest = right;
}
 
if(largest != i) {
    swap(arr, i, largest);
    heapify(arr, largest);
} }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}&lt;/p&gt;

&lt;p&gt;function heapSort(arr) {
    buildMaxHeap(arr);&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(var i = arr.length - 1; i &amp;gt; 0; i--) {
    swap(arr, 0, i);
    len--;
    heapify(arr, 0);
}
return arr; } ``` ## 计数排序 ``` function countingSort(arr, maxValue) {
var bucket = newArray(maxValue + 1),
    sortedIndex = 0;
    arrLen = arr.length,
    bucketLen = maxValue + 1;
 
for(var i = 0; i &amp;lt; arrLen; i++) {
    if(!bucket[arr[i]]) {
        bucket[arr[i]] = 0;
    }
    bucket[arr[i]]++;
}
 
for(var j = 0; j &amp;lt; bucketLen; j++) {
    while(bucket[j] &amp;gt; 0) {
        arr[sortedIndex++] = j;
        bucket[j]--;
    }
}
 
return arr; } ``` ## 桶排序 ``` function bucketSort(arr, bucketSize) {
if(arr.length === 0) {
  returnarr;
}
 
var i;
var minValue = arr[0];
var maxValue = arr[0];
for(i = 1; i &amp;lt; arr.length; i++) {
  if(arr[i] &amp;lt; minValue) {
      minValue = arr[i];                // 输入数据的最小值
  } else if(arr[i] &amp;gt; maxValue) {
      maxValue = arr[i];                // 输入数据的最大值
  }
}
 
// 桶的初始化
var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  
var buckets = newArray(bucketCount);
for(i = 0; i &amp;lt; buckets.length; i++) {
    buckets[i] = [];
}
 
// 利用映射函数将数据分配到各个桶中
for(i = 0; i &amp;lt; arr.length; i++) {
    buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
}
 
arr.length = 0;
for(i = 0; i &amp;lt; buckets.length; i++) {
    insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
    for(var j = 0; j &amp;lt; buckets[i].length; j++) {
        arr.push(buckets[i][j]);                     
    }
}
 
return arr; } ``` ## 基数排序 ``` var counter = []; function radixSort(arr, maxDigit) {
var mod = 10;
var dev = 1;
for(var i = 0; i &amp;lt; maxDigit; i++, dev *= 10, mod *= 10) {
    for(var j = 0; j &amp;lt; arr.length; j++) {
        varbucket = parseInt((arr[j] % mod) / dev);
        if(counter[bucket]==null) {
            counter[bucket] = [];
        }
        counter[bucket].push(arr[j]);
    }
    var pos = 0;
    for(var j = 0; j &amp;lt; counter.length; j++) {
        var value = null;
        if(counter[j]!=null) {
            while((value = counter[j].shift()) != null) {
                  arr[pos++] = value;
            }
      }
    }
}
return arr; } ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 28 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/28/%E6%8E%92%E5%BA%8F.html</link>
        <guid isPermaLink="true">/2020/07/28/%E6%8E%92%E5%BA%8F.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Android面基2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Android 相关部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;自定义-view&quot;&gt;自定义 View&lt;/h2&gt;
&lt;h2 id=&quot;事件拦截分发&quot;&gt;事件拦截分发&lt;/h2&gt;
&lt;h2 id=&quot;性能优化工具&quot;&gt;性能优化工具&lt;/h2&gt;
&lt;h2 id=&quot;https请求慢的解决办法dns携带数据直接访问-ip&quot;&gt;Http[s]请求慢的解决办法（DNS、携带数据、直接访问 IP）&lt;/h2&gt;
&lt;h2 id=&quot;缓存自己如何实现lrucache-原理&quot;&gt;缓存自己如何实现（LRUCache 原理）&lt;/h2&gt;
&lt;h2 id=&quot;图形图像相关opengl-es-管线流程egl-的认识shader-相关&quot;&gt;图形图像相关：OpenGL ES 管线流程、EGL 的认识、Shader 相关&lt;/h2&gt;
&lt;h2 id=&quot;surfaceviewtextureviewglsurfaceview-区别及使用场景&quot;&gt;SurfaceView、TextureView、GLSurfaceView 区别及使用场景&lt;/h2&gt;
&lt;h2 id=&quot;动画差值器估值器android中的view动画和属性动画-android-动画-介绍与使用&quot;&gt;动画、差值器、估值器（Android中的View动画和属性动画 、Android 动画 介绍与使用）&lt;/h2&gt;
&lt;h2 id=&quot;mvcmvpmvvm&quot;&gt;MVC、MVP、MVVM&lt;/h2&gt;
&lt;h2 id=&quot;handlerthreadlocalasynctaskintentservice-原理及应用&quot;&gt;Handler、ThreadLocal、AsyncTask、IntentService 原理及应用&lt;/h2&gt;
&lt;h2 id=&quot;gradlegroovy-语法gradle-插件开发基础&quot;&gt;Gradle（Groovy 语法、Gradle 插件开发基础）&lt;/h2&gt;
&lt;h2 id=&quot;热修复插件化&quot;&gt;热修复、插件化&lt;/h2&gt;
&lt;h2 id=&quot;组件化架构思路&quot;&gt;组件化架构思路&lt;/h2&gt;
&lt;h2 id=&quot;系统打包流程&quot;&gt;系统打包流程&lt;/h2&gt;
&lt;h2 id=&quot;android-有哪些存储数据的方式&quot;&gt;Android 有哪些存储数据的方式。&lt;/h2&gt;
&lt;h2 id=&quot;sharedprefrence-源码和问题点&quot;&gt;SharedPrefrence 源码和问题点；&lt;/h2&gt;
&lt;h2 id=&quot;sqlite-相关&quot;&gt;sqlite 相关&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;创建或者打开数据库
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class DBHelper extends SQLiteOpenHelper {
  private static final String DATABASE_NAME = &quot;db.db&quot;;
  private static final int DATABASE_VERSION = 1;

  /** Create a helper object for the Events database */
  public ProvinceDataHelper(Context ctx) {
      super(ctx, DATABASE_NAME, null, DATABASE_VERSION);
  }

  @Override
  public void onCreate(SQLiteDatabase db) {}

  @Override
  public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;增删改查
```&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

+ 如何导入外部数据库
1.将格式为.db的数据库文件放到android项目assets目录中；
2.在程序必要的时候，将其“拷贝”（文件读取）到Android 程序默认的数据库存储目录中，一般路径为“/data/data/项目包名/databases/“；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;InputStream is = context.getAssets().open(DB_NAME);
                // 输出流,在指定路径下生成db文件
                OutputStream os = new FileOutputStream(DB_PATH + DB_NAME);&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            // 文件写入
            byte[] buffer = new byte[1024];
            int length;
            while ((length = is.read(buffer)) &amp;gt; 0) {
                os.write(buffer, 0, length);
            } ``` 3.自定义SQLiteOpenHelper类，创建一个名字跟步骤1中.db名称一样的数据库； 4.按照平常逻辑，增删改查数据库。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h2 id=&quot;如何判断一个-app-在前台还是后台&quot;&gt;如何判断一个 APP 在前台还是后台？&lt;/h2&gt;
&lt;h2 id=&quot;ams-pms&quot;&gt;AMS 、PMS&lt;/h2&gt;
&lt;h2 id=&quot;activity-启动流程app-启动流程&quot;&gt;Activity 启动流程，App 启动流程&lt;/h2&gt;
&lt;h2 id=&quot;binder-机制ipcaidl-的使用&quot;&gt;Binder 机制（IPC、AIDL 的使用）&lt;/h2&gt;
&lt;h2 id=&quot;为什么使用-parcelable好处是什么&quot;&gt;为什么使用 Parcelable，好处是什么？&lt;/h2&gt;
&lt;h2 id=&quot;android-图像显示相关流程vsync-信号等&quot;&gt;Android 图像显示相关流程，Vsync 信号等&lt;/h2&gt;
&lt;h2 id=&quot;invalidate和postinvalidate的区别及使用&quot;&gt;invalidate和postInvalidate的区别及使用&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Android中实现View的更新有两组方法，1. invalidate,ui线程更新; 2. postInvalidate，非UI线程更新&lt;/li&gt;
  &lt;li&gt;invalidate是在handler中使用，postInvalidate可以直接在子线程中调用更新View。
    &lt;h2 id=&quot;activity-window-view三者的差别&quot;&gt;Activity-Window-View三者的差别&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Activity是Android四大组件之一，负责界面展示、用户交互和逻辑处理,有一个内部对象window。&lt;/li&gt;
  &lt;li&gt;Window就是负责界面展示以及交互的只能部门，就相当于Activity的下属，Activity的生命周期方法负责业务的处理。&lt;/li&gt;
  &lt;li&gt;View就是放在Window容器的元素，Window是View的载体，View是Window的具体展示。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 在Activity中调用attach，创建了一个Window
2. 创建的window是其子类PhoneWindow，在attach中创建PhoneWindow
3. 在Activity中调用setContentView(R.layout.xxx)
4. 其中实际上是调用的getWindow().setContentView()
5. 调用PhoneWindow中的setContentView方法
6. 创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）
7. 将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】
8. 调用到ViewGroup
9. 调用ViewGroup的removeAllView()，先将所有的view移除掉
10. 添加新的view：addView()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;context&quot;&gt;Context&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Context数量=Activity数量+Service数量+1&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 27 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/27/Android%E9%9D%A2%E5%9F%BA-2.html</link>
        <guid isPermaLink="true">/2020/07/27/Android%E9%9D%A2%E5%9F%BA-2.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Android 面试 Java部分</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;java 相关&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;容器（HashMap、HashSet、LinkedList、ArrayList、数组等）
内存模型
垃圾回收算法（JVM）
垃圾回收机制和调用 System.gc()的区别？
类加载过程（需要多看看，重在理解，对于热修复和插件化比较重要）
反射
多线程和线程池
设计模式（六大基本原则、项目中常用的设计模式、手写单例等）
Java 四大引用
Java 的泛型
final、finally、finalize 的区别
接口、抽象类的区别&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/27/Android-%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80.html</link>
        <guid isPermaLink="true">/2020/07/27/Android-%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>http 及其抓包</title>
        <description>
</description>
        <pubDate>Sat, 18 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/18/Android-http.html</link>
        <guid isPermaLink="true">/2020/07/18/Android-http.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>svg 在Android中的使用</title>
        <description>
</description>
        <pubDate>Fri, 17 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/17/svg.html</link>
        <guid isPermaLink="true">/2020/07/17/svg.html</guid>
        
        <category>android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>node jwt 苹果登录验证</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;苹果登录有两种方式验证：jwt形式；code授权码形式.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jwt&quot;&gt;jwt&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;格式：heard.paylod.signture&lt;/li&gt;
  &lt;li&gt;signtura生成方式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;解析之后
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ header: {
   kid: '86D32Kf',
   alg: 'RS256' 
 },
payload: 
 { iss: 'https://appleid.apple.com',
   aud: 'com.company.product',
   exp: 1594712245,
   iat: 1594711645,
   sub: '001610.d0b9dfa70cc24cd79f5bba662c625102.0718',
   c_hash: 'tlydpf-lV51Gi2pKAGZKCA',
   email: '5u2nbamwvm@privaterelay.appleid.com',
   email_verified: 'true',
   is_private_email: 'true',
   auth_time: 1594711645,
   nonce_supported: true },
signature:'es-mMU2FRsILnqmo_G5VbNKMz9gHtL9GjtyuiiiiiiiiP5J9ZhttU1_EJBEDBkBnR1jcrq_xM7kCpq357aN_EAC6G7bgGq4_RrAlG8XwEj4RSo1GoYQX1F0sby0SQrf1D_NZzdirjuUX7yNf-ZoeglyBg-7e-CbTjqfYBOswh_jsTWZ-I3vM-Ctcg12E5tUk345678jzaKpzIuL4KvlALM-VrY-Wp_7mFj4a3KKAxls0ojAjD434EL6oPDT8452j8QOWRFtPRttrqLqfpQbJJeXMCJkW5qIKeI9CU7v6Bpo5RLz3P8yGLrUoY3UJXyKT5_5MEs2bbw' }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nodejs实现&quot;&gt;nodejs实现&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var jwt = require('jsonwebtoken');
const jwksClient = require('jwks-rsa');
// 获取苹果公钥json
var jwt_client = jwksClient({
    jwksUri: 'https://appleid.apple.com/auth/keys'
});
exports.verifyAppleSignin = function(req, res) {
    let jwtToken = req.param('jwtToken');
    // 解析出完整的jwt数据
    let jwtStr = jwt.decode(jwtToken, { complete: true })
    jwt_client.getSigningKey(jwtStr.header.kid, function(err, key) {
        // 通过header里的kid和公钥json里的kid匹配，生成公钥
        // 当然也可以自己通过n和e生成公钥
        let signingKey = key.rsaPublicKey;
        // 验证，是否一致
        jwt.verify(jwtToken, signingKey, (err, data) =&amp;gt; {
            if (!err) {
                console.log('verifyAppleSignin,verify ok')
            } else {
                console.log('err', err);
            }
        })
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 01 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/01/node%E8%8B%B9%E6%9E%9C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.html</link>
        <guid isPermaLink="true">/2020/07/01/node%E8%8B%B9%E6%9E%9C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.html</guid>
        
        <category>nodejs</category>
        
        
        <category>nodejs</category>
        
      </item>
    
      <item>
        <title>deno</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;自己创建的自己亲手毁掉，哈哈哈哈，有意思&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;安装
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install deno
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;deno -h&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deno 0.32.0
A secure JavaScript and TypeScript runtime // 安全的JavaScript和TypeScript运行时
Docs: https://deno.land/std/manual.md
Modules: https://deno.land/x/
Bugs: https://github.com/denoland/deno/issues
To run the REPL supply no arguments:

  deno
To evaluate code from the command line:

  deno eval &quot;console.log(30933 + 404)&quot;
To execute a script:

  deno https://deno.land/std/examples/welcome.ts
The default subcommand is 'run'. The above is equivalent to

  deno run https://deno.land/std/examples/welcome.ts
See 'deno help run' for run specific flags.
USAGE:
    deno [SUBCOMMAND]
OPTIONS:
    -h, --help                     Prints help information
    -L, --log-level &amp;lt;log-level&amp;gt;    Set log level [possible values: debug, info]
    -V, --version                  Prints version information
SUBCOMMANDS:
    bundle         Bundle module and dependencies into single file
    completions    Generate shell completions
    eval           Eval script
    fetch          Fetch the dependencies
    fmt            Format files
    help           Prints this message or the help of the given subcommand(s)
    info           Show info about cache or info related to source file
    install        Install script as executable
    repl           Read Eval Print Loop
    run            Run a program given a filename or url to the source code
    test           Run tests
    types          Print runtime TypeScript declarations
ENVIRONMENT VARIABLES:
    DENO_DIR       Set deno's base directory
    NO_COLOR       Set to disable color
    HTTP_PROXY     Proxy address for HTTP requests (module downloads, fetch)// 请求的HTTP_PROXY代理地址（模块下载，获取）
    HTTPS_PROXY    Same but for HTTPS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 01 Jul 2020 00:00:00 +0800</pubDate>
        <link>/2020/07/01/deno.html</link>
        <guid isPermaLink="true">/2020/07/01/deno.html</guid>
        
        <category>deno</category>
        
        
        <category>deno</category>
        
      </item>
    
      <item>
        <title>日常记录</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;记忆是一场没有尽头的纪录片&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Foxmail
    &lt;blockquote&gt;
      &lt;p&gt;今天突然想更换一下GitHub的邮箱，因为现在这些老外不太靠谱了，又加上翻墙困难，哪天Gmail无法登陆了就凉凉了，竟然发现Foxmail没有入口，一顿搜索，发现foxmail 在2005年被腾讯收购，需要在qq邮箱注册Foxmail。然后设置独立密码，于是我的GitHub就可以用双号登陆啦。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 30 Jun 2020 00:00:00 +0800</pubDate>
        <link>/2020/06/30/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95.html</link>
        <guid isPermaLink="true">/2020/06/30/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95.html</guid>
        
        <category>read</category>
        
        
        <category>read</category>
        
      </item>
    
      <item>
        <title>Git 笔记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;2005年，神一样的linus，两周就用C写完了Git，一个月之内，Linux系统的源码已经由Git管理了，2008年，GitHub上线，为开源项目免费提供Git存储。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Git分布式管理
    &lt;blockquote&gt;
      &lt;p&gt;CVS和SVN是集中式管理，必须联网，与中央服务器沟通。Git在本地即可管理版本，在中央服务器与别人的版本合并&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Git安装
    &lt;blockquote&gt;
      &lt;p&gt;Git最早只能在Linux和Unix系统上，目前各大系统都可以了。
linux安装：sudo apt-get install git
mac安装: brew install git (mac安装homebrew：/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”)
windows安装：下载gitbash for Windows&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;git创建仓库
    &lt;blockquote&gt;
      &lt;p&gt;通常情况下，mkdir 一个路径，然后 git  init 
此时，会生出.git文件，以后版本管理就有这个文件了&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;关联GitHub
    &lt;blockquote&gt;
      &lt;p&gt;在 GitHub上创建一个空仓库
在本地仓库目录： git remote add origin（远程哭名字） git@github.com:GitHub账户名/xxx.git
git push -u origin master&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;clone
    &lt;blockquote&gt;
      &lt;p&gt;git clone，Git支持多种协议，包括https，但ssh协议速度最快。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;花式操作分支
```&lt;/li&gt;
  &lt;li&gt;查看远程分支：git branch -a&lt;/li&gt;
  &lt;li&gt;查看本地分支：git branch&lt;/li&gt;
  &lt;li&gt;创建分支：git branch  xxx&lt;/li&gt;
  &lt;li&gt;切换分支：git checkout/switch   xxx&lt;/li&gt;
  &lt;li&gt;创建并切换：git checkout -b dev// git switch  -b dev&lt;/li&gt;
  &lt;li&gt;合并分支：git merge dev&lt;/li&gt;
  &lt;li&gt;删除分支：git branch -d dev
```&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;–pretty=oneline
git add xx 添加修改到暂存区stage// git add . // git log // git status // git diff // git diff xxx         // git commit -m ‘xx’ 把修改从暂存区的所有提交到当前分支 // git push // git rest –hard HEAD^(HEAD^^,HEAD~100)//  git reset –hard 1094a回退版本(id只写前几位即可)// git reflog记录之前的命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;git config –global i18n.logOutputEncoding gbk //
git config –global i18n.commitEncoding gbk
git checkout –file // 撤销未提交的修改
git checkout xx 切换分支
git reset HEAD xx 把xx文件从暂存区恢复到工作区
git rm删掉，并且git commit&lt;/p&gt;

&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 30 Jun 2020 00:00:00 +0800</pubDate>
        <link>/2020/06/30/git.html</link>
        <guid isPermaLink="true">/2020/06/30/git.html</guid>
        
        <category>Tool</category>
        
        
        <category>Tool</category>
        
      </item>
    
  </channel>
</rss>
